[{"content":"","date":"February 19, 2023","permalink":"/tags/go/","section":"Tags","summary":"","title":"go"},{"content":" Introduction In late 2022, I put together my roadmap for projects to tackle in 2023, many of which revolved around Go and high performance development. I had spent a good part of the year in tutorial hell, teaching myself how to build distributed systems in Go. After much toil, I finally felt ready to start building complex projects of my own.\nAt the end of the year, curiosity got the best of me and I started to look into Rust. What I learned not only put my 2023 goals into question, but my career goals as well.\nShould I drop Go and shift my focus to Rust?\nIn this blog, I’d like to share my thoughts on Go vs Rust and how I came to decide on what programming language to prioritize next.\nPros and Cons The languages can be summed up as follows.\nGo Go was built with simplicity in mind, with a goal of enabling developers to write more high performance code with lower complexity. While Go is easier to learn and use, it omits features commonly found in other popular languages. As a result, it contradicts with many well established programming paradigms - a point of controversy amongst programmers. Furthermore, Go uses a Garbage Collector, which hinders the developers control over a system’s CPU and memory usage.\nRust Rust is a general purpose language that rivals the performance of C/C++. Above all, Rust prioritizes memory safety and containment, eliminating the risk of memory bugs. It uses the concepts of variable scopes, borrowing, and lifetimes - all of which contribute to Rust’s steep learning curve. The safety features are a tradeoff for fast development due to its intricacy, which may increase amongst larger collaborative teams.\nVerdict So, between Go and Rust, which of the two would I rather master?\nRust.\nConsider the fact that 70% of bugs at Microsoft are due to memory safety - an example that is indicative of how prevalent memory bugs can be. Because of how Rust was designed to be written, programs won’t compile if there is an error with memory handling. A prospect of no memory bugs in a code base is game changing - think of all of the time and effort towards debugging that can be avoided! Rust is also blazingly fast; another bonus for those who are persistent enough to master the language.\nSo then, why am I prioritizing Go?\nSolving Problems During my dilemma in trying to decide between Go and Rust, I stumbled on a blog post \u0026#34;Teach Yourself Programming in 10 years\u0026#34;. In essence, the argument made is that mastering programming doesn\u0026#39;t happen over night, but over the course of several years. It suggests that one should try many languages, understand their implementation and the primary problems that those languages were built to solve.\nReflecting on this idea, I pondered over where I currently stood in my path towards mastery. What problems am I trying to solve?\nI want to architect and build enterprise level distributed systems; scalability implied.\nRust is a great general-purpose language, one that especially excels in systems programming. The enforcement of memory safety and the means by which it accomplishes it are already changing the paradigm of how we think of programming as a whole. Not to mention, Rust is the preferred language for Web Assembly, a standardized binary format set to change the future of cloud native.\nStill, Go is the programming language that is best suited for the problems I am trying to solve now. It has its fair share of deserved criticism, but it is the most prevelant language used for cloud native development. It\u0026#39;s high performance, concurrency features, and fast development cycles are hard to beat.\nFor those reason, I\u0026#39;ve decided to priortize Go over Rust at this point in time.\nRest assured though, Rust is gaining far too much traction to be ignored; it is not too far down my road towards mastery.\n","date":"February 19, 2023","permalink":"/posts/go-vs-rust/","section":"Posts","summary":"Introduction In late 2022, I put together my roadmap for projects to tackle in 2023, many of which revolved around Go and high performance development. I had spent a good part of the year in tutorial hell, teaching myself how to build distributed systems in Go.","title":"Go vs Rust: Why I chose Go... for now"},{"content":"","date":"February 19, 2023","permalink":"/","section":"Jesse Molina","summary":"","title":"Jesse Molina"},{"content":"","date":"February 19, 2023","permalink":"/tags/opinion/","section":"Tags","summary":"","title":"opinion"},{"content":"","date":"February 19, 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"February 19, 2023","permalink":"/tags/rust/","section":"Tags","summary":"","title":"rust"},{"content":"","date":"February 19, 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"March 17, 2022","permalink":"/tags/azure/","section":"Tags","summary":"","title":"azure"},{"content":"","date":"March 17, 2022","permalink":"/tags/terraform/","section":"Tags","summary":"","title":"terraform"},{"content":" Terraform is an open-source tool that allows cloud provider APIs to be expressed as declarative configuration files, enabling Infrastructure-as-Code.\nIn layman\u0026#39;s terms, rather than manually creating resources on Azure, AWS, GCP, etc., we can express our resource architecture as code (hence IaC).\nWith our cloud infrastructure defined as code, we are able to take advantage of DevOps tools and practices to maintain, test, and deploy our configuration via CI/CD pipelines. Furthermore, it facilitates our ability to scale our services in the cloud and allows engineers to have a better mental model of our deployments.\nIn this post, we will review the main concepts of Terraform in order to get you started. We will use Azure in our examples, but the same logic applies for any other provider.\nTerraform Setup Visit the Terraform installation page to get started.\nIn my case, I can use a package manager to search for and install Terraform.\npacman -Ss terraform community/terraform 1.1.6-1 [installed] HashiCorp tool for building and updating infrastructure as code idempotently Once installed, we can validate the terraform version in use.\nterraform version Terraform v1.1.6 on linux_amd64 A terraform project can be started within an empty.\nmkdir example cd example File Extensions Terraform uses file extensions to define a file\u0026#39;s functionality and purpose within a Terraform project. In fact, filenames default to terraform.tfextension.\nexample/ ├── terraform.tf ├── terraform.tfplan ├── terraform.tfstate ├── terraform.tfvars .tf The primary file extension for Terraform code. This file defines what cloud provider to use and what resources will be created on it. It is common practice to rename this file as main.tf and for code to be split up into multiple .tf files to separate the logic in the code.\n.tfvars / .tfvars.json Defines the variable values that are passed into the Terraform code. These values allow us to dynamically define and build the Terraform environments. It is possible to have multiple .tfvars files, for example, on the basis of environments (i.e dev.tfvars, prod.tfvars).\nVariables can also be written in JSON using the .tfvars.json file extension.\n.tfstate A generated state file that keeps track of all resources in a Terraform environment. While this file can exist within the source code, it\u0026#39;s often best to store the state in a remote location when collaborating with others.\n.tfplan A generated execution plan that defines the actions Terraform would take if the configurations were to be applied. Plans can be saved and passed into Terraform to apply.\nConfiguration Syntax Terraform code is written in Blocks. There are many different blocks, each with their own functionality and arguments.\nIn example, a resource block is used to create an azure resource group named example with a value provided for the name argument.\nresource \u0026#34;azurerm_resourcegroup\u0026#34; \u0026#34;example\u0026#34; { name = \u0026#34;my-example-resource-group\u0026#34; ... } The following are the different blocks that can be defined in the code.\nexample/ ├── main.tf Providers Providers are Terraform plugins that allow Terraform to work with cloud providers and APIs.\nThere are many open source providers to choose from, each with their unique configurations and documentation; check out the terraform registry to browse the available options.\nIn this example, we are provisioning Azure resources using the azurerm provider and specify the required version.\nterraform { required_providers { azurerm = { source = \u0026#34;hashicorp/azurerm\u0026#34; version = \u0026#34;=2.91.0\u0026#34; } } } We can expand on our provider block by changing the default backend for where the .tfstate file will be hosted.\nIn this example, we are using an Azure Blob Storage container to host our Terraform state via \u0026#34;azurerm\u0026#34;. Alternative backends are HashiCorp Vault or most cloud object storage providers (i.e. AWS S3, GCP Cloud Storage).\nterraform { required_providers { ... } backend \u0026#34;azurerm\u0026#34; { resource_group_name = \u0026#34;example-resource-group\u0026#34; storage_account_name = \u0026#34;examplestorageaccountname\u0026#34; container_name = \u0026#34;example-containter-name\u0026#34; key = \u0026#34;terraform.tfstate\u0026#34; } } A connection to our Azure subscription can be initialized with a provider block for \u0026#34;azurerm\u0026#34;. Rather than hard coding values into the argument block, variables from definitions can be passed instead.\nprovider \u0026#34;azurerm\u0026#34; { subscription_id = \u0026#34;example-subscription-ido\u0026#34; tenant_id = var.sub.tenant_id features {} } Resource Resource blocks are the primary blocks used in Terraform code. They are used to create and describe one or more infrastructure objects, such as kubernetes clusters, application gateways, etc.\nEach provider exposes their corresponding resources, all of which have their unique definitions. Be sure to review the documentation for whatever provider you intend to use.\nresource \u0026#34;azurerm_resourcegroup\u0026#34; \u0026#34;example\u0026#34; { name = \u0026#34;rg-example\u0026#34; location = \u0026#34;West Europpe\u0026#34; } Variables Variable blocks define the variables that can be dynamically passed into the terraform code.\nVariables are defined with the name, type, and optionally, the default value. The different types of variables include string, bool, number, and map.\nvariable name { type = string } variable count { type = number default = 2 } More complex variables can be defined as type object, whose values can be accessed using dot notation.\nvariable sub { type = object { subscription_id = string tenant_id = string } } Data Data blocks are used to gather information from existing resources.\ndata \u0026#34;azurerm_subnet\u0026#34; \u0026#34;example\u0026#34; { name = var.sn_name virtual_network_name = data.azurerm_virtual_network.default.name resource_group_name = data.azurerm_virtual_network.default.resource_group_name } These code blocks allow us to pass values into other code blocks using dot notation. For example, we can pass a data.azurerm_subnet.default.id value into the subnet_id argument, as shown below.\nresource \u0026#34;azurerm_network_interface\u0026#34; \u0026#34;example\u0026#34; { ... ip_configuration { name = \u0026#34;internal\u0026#34; subnet_id = data.azurerm_subnet.example.id private_ip_address_allocation = \u0026#34;Dynamic\u0026#34; } } Modules All Terraform providers can be considered to be modules: collection of Terraform code that facilitates our ability to create resources.\nIn similar fashion, we can create our own Terraform modules to ease code repetition and abstract collection of resources we might want to build in conjunction (i.e. network load balancer with collection of load balancer rules).\nThis post won\u0026#39;t dive into modules, but in essence, modules are written in Terraform code and can be saved in their own respective directory (i.e. modules). In the modules block, the directory location is passed into the source argument.\nmodule \u0026#34;load_balancer_west_europe\u0026#34; { source = \u0026#34;modules/app_load_balancer\u0026#34; name = var.app_weu.load_balancer_name ... } module \u0026#34;load_balancer_east_europe\u0026#34; { source = \u0026#34;modules/app_load_balancer\u0026#34; name = var.app_weu.load_balancer_name ... } Visit the modules documentation for more details.\nOutputs Output blocks allow us to export resources or resource properties to be used within our Terraform code.\nThe most common use case for an Output is for when we write modules. For example, our module can create a load balancer whose load balancer ID may be leveraged to build other resources.\nWe don\u0026#39;t necessarily have to expose everything that is created within our module, but instead can share specific parameters.\noutput \u0026#34;load_balancer_id\u0026#34; { value = azurerm_lb.example.id } Again, we can leverage the output parameters for other resources. In this example, the load_balancer_east_europe module has exposed the load_balancer_id.\nresource \u0026#34;azurerm_lb_backend_address_pool\u0026#34; \u0026#34;example\u0026#34; { name = \u0026#34;bep-example\u0026#34; loadbalancer_id = module.load_balancer_east_europe.load_balancer_id resource_group_name = \u0026#34;rg-example\u0026#34; } File Structure While we can write out entire Terraform code into one file, it\u0026#39;s often best to break the code into multiple files. As stated earlier, Terraform doesn\u0026#39;t care for the name of the file, but the extension that is being used, giving us some liberty for how we want to name our files. While there isn\u0026#39;t a definitive naming convention, it is common to write the code blocks into their respective file.\nexample/ ├── main.tf ├── outputs.tf ├── variables.tf ├── terraform.tfvars ├── ... The file structure can be more complex as well, especially when we consider modules and code for multiple environments.\nFor example, I tend to write my terraform code as follows. There is no standard convention for directory structure either, so you\u0026#39;re free to build your project as you see fit.\n├── environments │ └── dev │ ├── dev.tfvars │ ├── main.tf │ └── variables.tf │ └── prod │ ├── prod.tfvars │ ├── main.tf │ └── variables.tf ├── modules │ ├── app_load_balancer │ │ ├── main.tf │ │ ├── outputs.tf │ │ └── variables.tf │ ├── app_vm_cluster │ │ ├── main.tf │ │ └── variables.tf ├── plans │ └── dev.tfplan │ └── prod.tfplan CLI Commands There are three primary command-line arguments used when developing Terraform code.\nterraform init Terraform init initializes the backend and installs all of our dependencies. It\u0026#39;s often best practice to run this command whenever you make significant code changes.\nterraform init Initializing the backend... Initializing provider plugins... - Reusing previous version of hashicorp/azurerm from the dependency lock file - Using previously-installed hashicorp/azurerm v2.91.0 Terraform has been successfully initialized! You may now begin working with Terraform. Try running \u0026#34;terraform plan\u0026#34; to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. terraform plan Terraform plan is the precursor to actually applying any changes and allows you to review what changes will be applied once executed.\nterraform plan The CLI output will show all new, modified, and deleted resources and properties.\nTerraform detected the following changes made outside of Terraform since the last \u0026#34;terraform apply\u0026#34;: # module.cribl_leader_vm_eus2.azurerm_network_interface.cribl_leader has changed ~ resource \u0026#34;azurerm_network_interface\u0026#34; \u0026#34;app_vm_cluster\u0026#34; { id = \u0026#34;/subscriptions/fake-subscription/fake-object-id\u0026#34; name = \u0026#34;example-name\u0026#34; + tags = { \u0026#34;Cost_Center_ID\u0026#34; = \u0026#34;111000\u0026#34; \u0026#34;Customer\u0026#34; = \u0026#34;Internal\u0026#34; \u0026#34;Environment_Type\u0026#34; = \u0026#34;Dev\u0026#34; \u0026#34;Product_Group\u0026#34; = \u0026#34;Internal\u0026#34; } # (10 unchanged attributes hidden) # (1 unchanged block hidden) } Upon running, Terraform will generate a terraform.plan file. You can create many plans, which can then be passed into Terraform to apply later.\nterraform apply Once we\u0026#39;re satisfied with our Terraform code, we can put it into action by running terraform apply.\nBy default, you will be prompted to confirm the changes before applying.\nterraform apply A word of caution! I advise that you run Terraform plan prior to running apply to verify what the changes will be. It\u0026#39;s completely possible to accidentally delete or modify a resource without intention.\nThank You Thanks for reading! Please be sure to share your thoughts in the comments section.\n","date":"March 17, 2022","permalink":"/posts/terraform-quickstart/","section":"Posts","summary":"Terraform is an open-source tool that allows cloud provider APIs to be expressed as declarative configuration files, enabling Infrastructure-as-Code.\nIn layman\u0026#39;s terms, rather than manually creating resources on Azure, AWS, GCP, etc.","title":"Terraform Quickstart"},{"content":"","date":"March 3, 2022","permalink":"/tags/github/","section":"Tags","summary":"","title":"github"},{"content":"","date":"March 3, 2022","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":" If you have a need to build and host a static website, consider using GitHub Pages to host and Hugo to generate the site.\nGitHub pages is a static site hosting service made available for free by GitHub. In essence, it uses a GitHub repository to serve content from the repo automatically; this alleviates the need to administer a webserver ourselves.\nHugo is a static site generator written in Go. It can be used to manage the look and feel of the website via templates, providing great versatility and speed when creating content (i.e. blog posts). Furthermore, it provides an easy-to-use runtime environment and spares the need for us to manage code dependencies.\nInstall and Initialize Hugo Hugo can be installed with the use of package managers (i.e. brew, choco, pacman). The option to build from source or run on docker are also available; check out the install guide for details.\nIn my case, I can find hugo via pacman using the CLI.\npacman -Ss hugo community/hugo 0.92.0-1 [installed: 0.89.4-1] Fast and Flexible Static Site Generator in Go Validate the hugo install by checking the version.\nhugo version hugo v0.89.4+extended linux/amd64 BuildDate=unknown Navigate to your preferred working directory and create the hugo site; I\u0026#39;m calling this site example.\nhugo new site example Navigating into the directory, we see that Hugo has created content for a basic hugo site.\ncd example tree . -L 1 example/ ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── resources ├── static └── themes 8 directories, 2 files Optionally, initialize a git repository for this project; the repository used for GitHub pages will be managed separately.\ngit init Configure a Theme Free themes for Hugo are available at themes.gohugo.io and many other websites.\nFind any particular theme and either clone the theme repository or add it as a submodule under example/themes.\ngit submodule add -f https://github.com/panr/hugo-theme-terminal.git themes/terminal The primary file used to configure Hugo is config.toml. Update the file to define the corresponding theme to be used.\nbaseURL = \u0026#34;https://www.example.com\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;Example\u0026#34; theme = \u0026#34;terminal\u0026#34; Additional Hugo site configurations can be made based on the theme selected. For an example site based on your theme, check out themes/\u0026lt;name\u0026gt;/exampleSite (if it exists).\ntree themes/terminal/exampleSite -L 1 example/themes/terminal/exampleSite ├── archetypes ├── config.toml ├── content ├── data ├── deploy.sh └── resources 4 directories, 2 files Write a Post and Serve The website pages are managed under example/content. To create a new blog post, create a file manually under example/content/posts/; hugo supports both markdown and org documents (hooray, emacs!).\nAlternatively, initialize the post with hugo from the CLI to include the metadata headers.\nhugo new posts/hello-world.md Run the hugo server and include draft documents when serving. By default, the site can be accessed via a web browser on localhost:1313.\nhugo server -D Configure GitHub Pages On GitHub, create the repository used to serve the GitHub pages and name it based on your GitHub username (username.github.io).\nFor example, jessemolina.github.io; visit pages.github.com for more details.\nOnce the repository has been created, add the new repository as a submodule under the public directory - this will host the static files required to generate the website.\ngit submodule add https://github.com/jessemolina/jessemolina.github.io.git public To generate the static files into the public directory, run hugo with theme flag. This command will need to executed each time a change is made or new content is created.\nhugo -t terminal Looking at public, we can see the populated content.\ntree public/ -L 1 ../../public ├── about ├── categories ├── css ├── images ├── index.html ├── index.xml ├── js ├── lib ├── posts ├── sitemap.xml └── tags 8 directories, 5 files Change directories, git commit and push to the remote username.github.io respository.\ncd public git add . git commit -m \u0026#39;init commit\u0026#39; git push After a few minutes, the website should be available online at username.github.io.\nCustom Domain If you have a custom domain name, you can add GitHub\u0026#39;s DNS records through your domain name service provider. Check out the github documentation for more details on how to configure pages to use your custom domain name address.\nThanks for reading.\n","date":"March 3, 2022","permalink":"/posts/hugo-on-github/","section":"Posts","summary":"If you have a need to build and host a static website, consider using GitHub Pages to host and Hugo to generate the site.\nGitHub pages is a static site hosting service made available for free by GitHub.","title":"Hugo Static Website on GitHub Pages"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]